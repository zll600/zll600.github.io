import{_ as n,c as l,as as p,G as t,B as a,o as d}from"./chunks/framework.BMhXnAva.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{"tags":["programming","sql"]},"headers":[],"relativePath":"blogs/programming/sql_optimize.md","filePath":"blogs/programming/sql_optimize.md"}'),r={name:"blogs/programming/sql_optimize.md"};function h(k,s,o,u,y,g){const i=a("NolebaseGitContributors"),e=a("NolebaseGitChangelog");return d(),l("div",null,[s[0]||(s[0]=p(`<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>业务场景是分⻚查询 user_info ⾥⾯ user_type 为 3 的 user，数据库使用的 Postgres 15</p><p>user_info 的 schema 如下</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> user_info</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    user_id    </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SERIAL</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    user_name  </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">VARCHAR</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    user_type  </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">INTEGER</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    created_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">TIMESTAMP</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> DEFAULT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> CURRENT_TIMESTAMP,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    updated_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">TIMESTAMP</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> DEFAULT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> CURRENT_TIMESTAMP,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    deleted_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">TIMESTAMP</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre></div><p>测试 sql 如下</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">EXPLAIN ANALYZE </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">VERBOSE</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_info</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1000000000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> deleted_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">is</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">DESC</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p>得到的查询计划如下：</p><table tabindex="0"><thead><tr><th style="text-align:left;">QUERY PLAN</th></tr></thead><tbody><tr><td style="text-align:left;">Limit (cost=0.29..1.91 rows=10 width=41) (actual time=0.008..0.014 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">-&gt; Index Scan Backward using user_info_pkey on public.user_info (cost=0.29..407.29 rows=2512 width=41) (actual time=0.007..0.012 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">Index Cond: (user_info.user_id &lt;= 1000000000)</td></tr><tr><td style="text-align:left;">Filter: ((user_info.deleted_at IS NULL) AND (user_info.user_type = 3))</td></tr><tr><td style="text-align:left;">Rows Removed by Filter: 33</td></tr><tr><td style="text-align:left;">Planning Time: 0.250 ms</td></tr><tr><td style="text-align:left;">Execution Time: 0.034 ms</td></tr></tbody></table><p>根据查询计划得知，会通过 PK 来扫，然后通过 where 条件过滤。</p><h2 id="优化思路" tabindex="-1">优化思路 <a class="header-anchor" href="#优化思路" aria-label="Permalink to &quot;优化思路&quot;">​</a></h2><h3 id="方案一-user-type-user-id-where-deleted-at-is-null" tabindex="-1">方案一 (user_type, user_id) where deleted_at is null <a class="header-anchor" href="#方案一-user-type-user-id-where-deleted-at-is-null" aria-label="Permalink to &quot;方案一 (user_type, user_id) where deleted_at is null&quot;">​</a></h3><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> idx_user_type_user_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_info(user_type, user_id) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> deleted_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">is</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p>执行上面的查询，得到的查询计划如下：</p><table tabindex="0"><thead><tr><th style="text-align:left;">QUERY PLAN</th></tr></thead><tbody><tr><td style="text-align:left;">Limit (cost=0.29..1.90 rows=10 width=41) (actual time=0.021..0.024 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">-&gt; Index Scan Backward using idx_user_type_user_id on public.user_info (cost=0.29..407.18 rows=2512 width=41) (actual time=0.020..0.022 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">Index Cond: ((user_info.user_type = 3) AND (user_info.user_id &lt;= 1000000000))</td></tr><tr><td style="text-align:left;">Planning Time: 0.264 ms</td></tr><tr><td style="text-align:left;">Execution Time: 0.043 ms</td></tr></tbody></table><p>这里的索引是是 user_type, user_id 联合索引。在该索引下，索引会先按照 <code>user_type</code> 排序，然后再按照 <code>user_id</code> 升序排序。</p><p>所以会先定位到 user_type = 3 的索引，然后再通过 user_id 定位到 user_id 小于 1000000000 的索引，然后再回表。</p><p>如果将查询 sql 改为下列的情况，则有：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">EXPLAIN ANALYZE </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">VERBOSE</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> *</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_info</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1000000000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> deleted_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">is</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">DESC</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p>得到的查询计划如下：</p><table tabindex="0"><thead><tr><th style="text-align:left;">QUERY PLAN</th></tr></thead><tbody><tr><td style="text-align:left;">Limit (cost=0.29..1.90 rows=10 width=41) (actual time=0.009..0.013 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">-&gt; Index Scan Backward using idx_user_type_user_id on public.user_info (cost=0.29..407.18 rows=2512 width=41) (actual time=0.008..0.011 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">Index Cond: ((user_info.user_type = 3) AND (user_info.user_id &lt;= 1000000000))</td></tr><tr><td style="text-align:left;">Planning Time: 0.100 ms</td></tr><tr><td style="text-align:left;">Execution Time: 0.024 ms</td></tr></tbody></table><p>这里修改了 where 子句中的查询条件，先命中 user_type，然后再命中 user_id。</p><h3 id="方案二-user-id-user-type-where-deleted-at-is-null" tabindex="-1">方案二 (user_id, user_type) where deleted_at is null <a class="header-anchor" href="#方案二-user-id-user-type-where-deleted-at-is-null" aria-label="Permalink to &quot;方案二 (user_id, user_type) where deleted_at is null&quot;">​</a></h3><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> idx_user_id_user_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_info (user_id, user_type) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> deleted_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">IS</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p>得到的查询计划如下：</p><table tabindex="0"><thead><tr><th style="text-align:left;">QUERY PLAN</th></tr></thead><tbody><tr><td style="text-align:left;">Limit (cost=0.29..1.90 rows=10 width=41) (actual time=0.017..0.022 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">-&gt; Index Scan Backward using idx_user_id_user_type on public.user_info (cost=0.29..406.47 rows=2512 width=41) (actual time=0.016..0.019 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">Index Cond: ((user_info.user_id &lt;= 1000000000) AND (user_info.user_type = 3))</td></tr><tr><td style="text-align:left;">Planning Time: 0.232 ms</td></tr><tr><td style="text-align:left;">Execution Time: 0.036 ms</td></tr></tbody></table><p>同样是联合索引，但是索引是 user_id, user_type 联合索引。所以会先定位到 user_id 小于 1000000000 的索引，然后再过滤 user_type = 3 的索引，然后再回表。</p><p>方案二可以和方案一对比，一般来讲 <code>user_id</code> 的离散度会比 <code>user_type</code> 更大，因此方案二会更稳定一些.</p><h3 id="方案三-user-id-where-user-type-3-and-where-deleted-at-is-null" tabindex="-1">方案三 user_id WHERE user_type = 3 AND WHERE deleted_at is null <a class="header-anchor" href="#方案三-user-id-where-user-type-3-and-where-deleted-at-is-null" aria-label="Permalink to &quot;方案三 user_id WHERE user_type = 3 AND WHERE deleted_at is null&quot;">​</a></h3><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> idx_user_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_info (user_id) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> deleted_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">IS</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p>得到的查询计划如下：</p><table tabindex="0"><thead><tr><th style="text-align:left;">QUERY PLAN</th></tr></thead><tbody><tr><td style="text-align:left;">Limit (cost=0.28..0.70 rows=10 width=41) (actual time=0.012..0.016 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">-&gt; Index Scan Backward using idx_user_id on public.user_info (cost=0.28..105.24 rows=2512 width=41) (actual time=0.011..0.014 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">Index Cond: (user_info.user_id &lt;= 1000000000)</td></tr><tr><td style="text-align:left;">Planning Time: 0.179 ms</td></tr><tr><td style="text-align:left;">Execution Time: 0.026 ms</td></tr></tbody></table><p>这里利用了 Postgres 的条件索引，所以会先定位到 user_id 小于 1000000000 的索引，然后再回表。但是这里只对有效查询结果的集合建立的索引。</p><p>方案三和方案二很像，但是方案三这里使用的是条件索引，因此相比方案二在空间、时间上的效率会提升一些。（整个索引树更小）</p><h3 id="方案四-user-id-desc-where-user-type-3-and-where-deleted-at-is-null" tabindex="-1">方案四 user_id DESC WHERE user_type = 3 AND WHERE deleted_at is null <a class="header-anchor" href="#方案四-user-id-desc-where-user-type-3-and-where-deleted-at-is-null" aria-label="Permalink to &quot;方案四 user_id DESC WHERE user_type = 3 AND WHERE deleted_at is null&quot;">​</a></h3><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> idx_user_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_info (user_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">DESC</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> user_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> deleted_at </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">IS</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><p>得到的查询计划如下：</p><table tabindex="0"><thead><tr><th style="text-align:left;">QUERY PLAN</th></tr></thead><tbody><tr><td style="text-align:left;">Limit (cost=0.28..0.70 rows=10 width=41) (actual time=0.018..0.022 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">-&gt; Index Scan using idx_user_id on public.user_info (cost=0.28..105.24 rows=2512 width=41) (actual time=0.017..0.020 rows=10 loops=1)</td></tr><tr><td style="text-align:left;">Output: user_id, user_name, user_type, created_at, updated_at, deleted_at</td></tr><tr><td style="text-align:left;">Index Cond: (user_info.user_id &lt;= 1000000000)</td></tr><tr><td style="text-align:left;">Planning Time: 0.229 ms</td></tr><tr><td style="text-align:left;">Execution Time: 0.035 ms</td></tr></tbody></table><p>方案四也可以和方案三对比，但是相比方案三，这里使用了倒序索引，更贴近这里的查询场景。</p><p>测试过程中使用脚本插入了 10000 条数据（from GPT）</p><div class="language-python3 vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python3</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>import psycopg2</span></span>
<span class="line"><span>from psycopg2 import sql</span></span>
<span class="line"><span>import random</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 连接到你的 PostgreSQL 数据库</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;NolebasePageProperties /&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>conn = psycopg2.connect(</span></span>
<span class="line"><span>    dbname=&quot;your_database_name&quot;,</span></span>
<span class="line"><span>    user=&quot;your_username&quot;,</span></span>
<span class="line"><span>    password=&quot;your_password&quot;,</span></span>
<span class="line"><span>    host=&quot;your_host&quot;,</span></span>
<span class="line"><span>    port=&quot;your_port&quot;</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 创建一个游标对象</span></span>
<span class="line"><span>cur = conn.cursor()</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 插入10000条数据</span></span>
<span class="line"><span>for i in range(10000):</span></span>
<span class="line"><span>    user_name = f&quot;user_{i}&quot;</span></span>
<span class="line"><span>    user_type = random.choice([0, 1, 2, 3])</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    cur.execute(</span></span>
<span class="line"><span>        sql.SQL(&quot;INSERT INTO user_info (user_name, user_type) VALUES (%s, %s)&quot;),</span></span>
<span class="line"><span>        [user_name, user_type]</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 提交事务</span></span>
<span class="line"><span>conn.commit()</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 关闭游标和连接</span></span>
<span class="line"><span>cur.close()</span></span>
<span class="line"><span>conn.close()</span></span></code></pre></div>`,40)),t(i),t(e)])}const D=n(r,[["render",h]]);export{_ as __pageData,D as default};
